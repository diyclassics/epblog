[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Data science + Latin literature"
  },
  {
    "objectID": "posts/wills-1996/index.html",
    "href": "posts/wills-1996/index.html",
    "title": "Gemination (Wills 1996)",
    "section": "",
    "text": "In the first part of his 1996 monograph on repetition in Latin poetry, Jeffrey Wills (1996) discusses gemination. i.e. “the repetition of a word in the same form in the same clause with no additional expansion.” In this notebook, we will formalize Wills’ definition of gemination into code using LatinCy.\nLet’s start by setting up a code notebook with Python imports, etc. We will use CLTK Readers with the CLTK-Tesserae texts as our exploratory background for gemination.\n\n# Imports\n\nfrom collections import Counter\nfrom natsort import natsorted\n\nimport spacy\nfrom cltkreaders.lat import LatinTesseraeCorpusReader\n\nfrom latintools import preprocess\n\nfrom tabulate import tabulate\nfrom IPython.core.display import HTML\nfrom IPython.display import display\n\nfrom tqdm import tqdm\n\nWills uses the following line from Virgil’s Eclogues to illustrate gemination (V. Ecl. 2.69):\n\nCorydon, Corydon, quae te dementia cepit!\n\nLet’s begin there.\n\n# Set up corpus\n\nT = LatinTesseraeCorpusReader()\n\n# Get Eclogues file\n\neclogues = [file for file in T.fileids() if 'eclogues' in file][0]\nprint(eclogues)\n\nvergil.eclogues.tess\n\n\nNext we load a LatinCy model to assist with matching Latin wordforms.\n\n# Set up NLP\n\nnlp = spacy.load('la_core_web_lg')\n\n\nSimple gemination\nConsidering Wills’ basic definition from above, we can use the following pseudocode as a starting point…\n\nGet a line of Virgil\n\nCreate a LatinCy Doc for each line\n\nCount the norm token attributes for each line\n\nCheck norm count, i.e. if the count of norm token attributes is greater than 1, then the line has gemination\n\nNote that Wills specifically defines the scope of gemination as a clause (not a line); we will return to this point in a future notebook where we introduce some clause parsing.\nGet a line of Virgil\nFor the Tesserae texts, CLTK Readers has a data structure called doc_rows that, at least for poetry, gives us a dictionary with the format {citation: line, etc.}. Let’s get the docrows for the Eclogues and print a sample line.\n\n# Get all Eclogue rows\n\ndocrows = next(T.doc_rows(eclogues))\n\n\n# Get a row\n\ntest = docrows['&lt;verg. ecl. 2.69&gt;']\nprint(test)\n\nAh, Corydon, Corydon, quae te dementia cepit!\n\n\nWe can already see our gemination—specifically the example Wills uses in his defintion—with the repetition of Corydon.\nCreate a LatinCy Doc\nNext we can create a spaCy Doc for each line. The Doc contains all sorts of annotations useful for philological work. We will use the norm token attribute here to help us match wordforms.\n\n# Create LatinCy Doc for line\n\ndoc = nlp(test)\nprint(type(doc))\n\n&lt;class 'spacy.tokens.doc.Doc'&gt;\n\n\n\n# Print norm examples\nprint(tabulate([[token.i, token.text, token.norm_] for token in doc], headers=['Index','Token', 'Norm']))\n\n  Index  Token     Norm\n-------  --------  --------\n      0  Ah        ah\n      1  ,         ,\n      2  Corydon   corydon\n      3  ,         ,\n      4  Corydon   corydon\n      5  ,         ,\n      6  quae      quae\n      7  te        te\n      8  dementia  dementia\n      9  cepit     cepit\n     10  !         !\n\n\nThinking ahead, if we use lines as is from the Tesserae texts, we have to deal with punctuation. Wills is concerned with the repetition of Corydon, not the repetition of the commas! One way we can deal with this is to preprocess the lines to remove punctuation before creating the Docs. We will discuss the philological implications of preprocessing in a future notebook. For now, we are going to import a script called preprocess that removes punctuation.\n\n# Create LatinCy Doc for preprocessed line and print example\n\ndoc = nlp(preprocess(test, lower=False))\nprint(tabulate([[token.i, token.text, token.norm_] for token in doc], headers=['Index','Token', 'Norm']))\n\n  Index  Token     Norm\n-------  --------  --------\n      0  Ah        ah\n      1  Corydon   corydon\n      2  Corydon   corydon\n      3  quae      quae\n      4  te        te\n      5  dementia  dementia\n      6  cepit     cepit\n\n\nCount the norm token attributes\nWe can now count the norm token attributes for each line using a Counter from the collections module.\n\n# Count `norm` attr in Doc tokens\n\nnorms = [token.norm_ for token in doc]\nnorms_counter = Counter(norms)\nprint(norms_counter)\n\nCounter({'corydon': 2, 'ah': 1, 'quae': 1, 'te': 1, 'dementia': 1, 'cepit': 1})\n\n\nCheck norm count\nWe can now check the norm count for each line. If the count is greater than 1, then the line has gemination.\n\ngeminations = [k for k, v in norms_counter.items() if v &gt; 1]\nprint(f'Number of geminations: {len(geminations)}')\nprint(f'{geminations}')\n\nNumber of geminations: 1\n['corydon']\n\n\nWe knew from Wills that this line would have gemination; of course, not all lines do.\n\n# Try a different line\n\ntest = docrows['&lt;verg. ecl. 2.70&gt;']\ndoc = nlp(preprocess(test))\nnorms = [token.norm_ for token in doc]\nnorms_counter = Counter(norms)\ngeminations = [k for k, v in norms_counter.items() if v &gt; 1]\n\nprint(doc.text)\nprint(f'Number of geminations: {len(geminations)}')\nprint(f'{geminations}')\n\nsemiputata tibi frondosa uitis in ulmo est\nNumber of geminations: 0\n[]\n\n\nHaving worked through our pseudocode, we can now put it all together into a function that we can use to check for gemination in any line of Latin poetry.\n\ndef get_geminations(Doc):\n    norms = [token.norm_ for token in Doc]\n    norms_counter = Counter(norms)\n    geminations = [k for k, v in norms_counter.items() if v &gt; 1]\n    return geminations    \n\nUsing this function, we can loop through the docrows for the Eclogues and check for gemination in each line. In the example below, we break after the first match as we are only checking at this point that the function works as expected.\n\nfor k, v in docrows.items():\n    doc = nlp(preprocess(v, lower=False))\n    geminations = get_geminations(doc)\n    if len(geminations) &gt; 0:\n        print(f'{k}: {geminations}')\n        print(f'{v}')\n        print('\\n')\n        break\n\n&lt;verg. ecl. 1.23&gt;: ['sic']\nsic canibus catulos similis, sic matribus haedos\n\n\n\n\nMore useful of course would be to collect all of the geminations into a data structure like a dictionary…\n\nvirgil_geminations = {}\n\nfor k, v in tqdm(docrows.items()):\n    doc = nlp(preprocess(v))\n    geminations = get_geminations(doc)\n    if geminations:\n        virgil_geminations[k] = (v, geminations)\n\nprint(f'There are {len(virgil_geminations)} geminations in Virgil\\'s *Eclogues*.')\n\n100%|██████████| 828/828 [00:03&lt;00:00, 207.68it/s]\n\n\nThere are 105 geminations in Virgil's *Eclogues*.\n\n\n\nprint('Here are the first five examples from our search:\\n')\nfor k, v in list(virgil_geminations.items())[:5]:\n    print(f'{k}: {v[0]}')\n\nHere are the first five examples from our search:\n\n&lt;verg. ecl. 1.23&gt;: sic canibus catulos similis, sic matribus haedos\n&lt;verg. ecl. 1.33&gt;: nec spes libertatis erat, nec cura peculi:\n&lt;verg. ecl. 1.63&gt;: aut Ararim Parthus bibet, aut Germania Tigrim,\n&lt;verg. ecl. 1.75&gt;: Ite meae, felix quondam pecus, ite capellae.\n&lt;verg. ecl. 2.20&gt;: quam dives pecoris, nivei quam lactis abundans.\n\n\nNote V. Ecl. 1.75 as an example of why we use norm instead of text for matching wordforms. Ite is capitalized here only because it is the first word in the sentence, but should be matched against ite regardless of case. Note the following in Python string matching…\n\nprint('Ite' == 'ite')\nprint('ite' == 'ite')\n\nFalse\nTrue\n\n\nWe can make it easier to see gemination in our texts by formatting matched tokens in HTML. We can use the display module from the IPython package to display the HTML in the notebook.\n\ndef display_gemination(gemination):\n    html = ''\n    line = nlp(gemination[0])\n    terms = gemination[1]\n\n    for token in line:\n        if token.norm_ in terms:\n            token = f'&lt;span style=\"color: green;\"&gt;{token}&lt;/span&gt;'\n        html += f'{token} '\n    return html\n\n\nprint('Here are the first five examples from our search:')\nfor k, v in list(virgil_geminations.items())[:5]:\n    # Note that if you do not remove the angle brackets from the Tesserae citation, it will be ignored as a (bad) HTML tag in the formatting below.\n    citation = k.replace('&lt;', '').replace('&gt;', '') \n    citation = f'&lt;span style=\"color: black; font-weight: bold;\"&gt;{citation}&lt;/span&gt;'\n    text = display_gemination(v)\n    html = '&lt;br&gt;'.join([citation, text])\n    html += '&lt;br&gt;&lt;br&gt;'\n    display(HTML(html))\n\nHere are the first five examples from our search:\n\n\nverg. ecl. 1.23sic canibus catulos similis , sic matribus haedos \n\n\nverg. ecl. 1.33nec spes libertatis erat , nec cura peculi : \n\n\nverg. ecl. 1.63aut Ararim Parthus bibet , aut Germania Tigrim , \n\n\nverg. ecl. 1.75Ite meae , felix quondam pecus , ite capellae . \n\n\nverg. ecl. 2.20quam dives pecoris , nivei quam lactis abundans . \n\n\nMoreover, we can write these matches to a file, formatting the geminations to make them easier to spot, here wrapping repeitions with asterisks.\n\ndef format_gemination(gemination):\n    txt = ''\n    line = nlp(gemination[0])\n    terms = gemination[1]\n\n    for token in line:\n        if token.norm_ in terms:\n            token = f'*{token}*'\n        txt += f'{token} '\n    return txt\n\nwith open('eclogue_geminations.txt', 'w') as f:\n    for k, v in virgil_geminations.items():\n        citation = k.replace('&lt;', '').replace('&gt;', '')\n        citation = f'{citation}'\n        text = format_gemination(v)\n        f.write(f'{citation}\\t{text}\\n')\n\nNote that a line like Ecl. 4.51 appears in the output…\n\nterrasque tractusque maris caelumque profundum !\n\n…as que is considered a token in the LatinCy model.\nAccordingly, we may want to have a way to drop certain tokens from our matching process. We add below an exclude parameter to the get_geminations function to accomplish this.\n\ndef get_geminations(Doc, exclude=[]):\n    norms = [token.norm_ for token in Doc]\n    norms_counter = Counter(norms)\n    geminations = [k for k, v in norms_counter.items() if v &gt; 1 and k not in exclude]\n    return geminations    \n\nexclude =['que']\n\ntest = nlp(preprocess(docrows['&lt;verg. ecl. 4.51&gt;'], lower=False))\n\nprint('Before...')\nprint(get_geminations(test))\nprint()\nprint('After...')\nprint(get_geminations(test, exclude=exclude))\n\nBefore...\n['que']\n\nAfter...\n[]\n\n\nWe write to file again, this time excluding que.\n\nvirgil_geminations = {}\n\nfor k, v in tqdm(docrows.items()):\n    doc = nlp(preprocess(v))\n    geminations = get_geminations(doc, exclude=['que'])\n    if geminations:\n        virgil_geminations[k] = (v, geminations)\n\nwith open('eclogue_geminations.txt', 'w') as f:\n    for k, v in virgil_geminations.items():\n        citation = k.replace('&lt;', '').replace('&gt;', '')\n        citation = f'{citation}'\n        text = format_gemination(v)\n        f.write(f'{citation}\\t{text}\\n')\n\n100%|██████████| 828/828 [00:03&lt;00:00, 213.19it/s]\n\n\nSo far, we have worked only with the Eclogues. We could easily expand this gemination search to other texts in the Tesserae corpus. Here is an example of expanding it to all epic poems in the collection.\n\n# Geminations in all Latin epic\n\n# Note here I get the year from the Tesserae metadata, sort the files chronologically, and then discard the date information\nepic = natsorted([(file, int(T.metadata('date', file))) for file in T.fileids() if T.metadata('genre', file) == 'epic'], key=lambda x: x[1])\nepic = [file for file, _ in epic]\nprint(f'There are {len(epic)} epic poems in the Tesserae collection.')\n\nThere are 120 epic poems in the Tesserae collection.\n\n\n\n# This takes about 7 minutes on my laptop\n\nall_geminations = {}\n\nfor file in tqdm(epic):\n    docrows = next(T.doc_rows(file))\n    for k, v in docrows.items():\n        doc = nlp(preprocess(v))\n        geminations = get_geminations(doc, exclude=['que'])\n        if geminations:\n            all_geminations[k] = (v, geminations)\n\n100%|██████████| 120/120 [06:49&lt;00:00,  3.42s/it]\n\n\n\n# Write to file\nwith open('epic_geminations.tsv', 'w') as f:\n    f.write('citation\\ttext\\n')\n    for k, v in all_geminations.items():\n        citation = k.replace('&lt;', '').replace('&gt;', '')\n        citation = f'{citation}'\n        text = format_gemination(v)\n        f.write(f'{citation}\\t{text}\\n')\n\nThis has been an introduction to formalizing a literary critical/philological argument using LatinCy, an example that barely takes us past the first page of Wills Part I. In subsequent notebooks, we will explore variations on gemination and other types of repetition.\n\n\nReferences\n\n\nWills, Jeffrey. 1996. Repetition in Latin Poetry: Figures of Allusion. Clarendon Press."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Exploratory Philology Blog",
    "section": "",
    "text": "Gemination (Wills 1996)\n\n\n\n\n\n\n\nreplicating-classics\n\n\nlatin\n\n\ndata-science\n\n\nallusion\n\n\n\n\nCode notebook providing basic formalization for ‘gemination’ as defined in Wills 1996\n\n\n\n\n\n\nJun 28, 2023\n\n\nPatrick J. Burns\n\n\n\n\n\n\nNo matching items"
  }
]